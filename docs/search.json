[
  {
    "objectID": "posts/machine_learning/11.hhl_imp5.html",
    "href": "posts/machine_learning/11.hhl_imp5.html",
    "title": "HHL Algorithm Implementation in Qiskit - Complete Version",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\nComplete HHL Implementation\n\n\n\nCode\n# Import necessary libraries\nimport qiskit\nimport numpy as np\nfrom numpy import pi\nfrom qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import UnitaryGate, QFT, RYGate, MCXGate\nfrom scipy.linalg import expm\n\n# previous functions\ndef state_prep(mat_A, vec_b, n_c=1):\n  N_b = vec_b.shape[0]\n  n_b = int(np.log2(N_b))\n  qr_b = QuantumRegister(n_b, name='b')  # b-register\n  qr_c = QuantumRegister(n_c, name='c')  # c-register\n  qr_a = QuantumRegister(1, name='a')    # a-register\n  qc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n\n  norm_b = vec_b / np.linalg.norm(vec_b)\n  qc.initialize(norm_b, qr_b)\n  return qc, qr_b, qr_c, qr_a\n\ndef phase_estimation(qc, qr_b, qr_c, mat_A, t):\n    n_c = len(qr_c)\n    \n    # 1. Hadamard on c-register\n    qc.h(qr_c)\n    \n    # 2. Apply controlled-U^(2^j) operations\n    U = expm(1j * t * mat_A)  # 计算 e^(iAt)\n    U_gate = UnitaryGate(U, label=\"e^{iAt}\")  # 创建 U gate\n  \n    for j in range(n_c):\n        power = 2**j  # 计算 U^(2^j)\n        controlled_U_pow = U_gate.power(power).control(1)  # 控制操作\n        qc.append(controlled_U_pow, [qr_c[j], *qr_b]) \n    \n    # 3. Apply IQFT on c-register\n    iqft = QFT(num_qubits=n_c, do_swaps=False).inverse()\n    qc.append(iqft, qr_c)  # 作用于 c-register\n    \n    return qc\n\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\ndef uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c):\n    \"\"\"\n    Complete uncomputation phase (Phase 4) of HHL algorithm\n    \"\"\"\n    # Step 1: Apply QFT on c-register\n    qc.append(QFT(n_c, do_swaps=False), qr_c)\n    \n    # Step 2: Inverse controlled-U operations\n    U_inv = expm(-1j * t * mat_A)\n    U_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")\n    \n    for j in reversed(range(n_c)):\n        power = 2**j\n        controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n        qc.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n    \n    # Step 3: Apply Hadamard on c-register\n    qc.h(qr_c)\n    \n    return qc\n\n\n\n\nCode\ndef hhl_algorithm(mat_A, vec_b, n_c=1, t=np.pi/8, C=0.01):\n    \"\"\"\n    Complete HHL algorithm implementation\n    Returns: quantum circuit and registers\n    \"\"\"\n    # Phase 1: State Preparation\n    qc, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=n_c)\n    \n    # Phase 2: Quantum Phase Estimation\n    qc = phase_estimation(qc, qr_b, qr_c, mat_A, t)\n    \n    # Phase 3: Controlled Rotation\n    qc = controlled_rotation(qc, qr_c, qr_a, C, t, n_c)\n    \n    # Phase 4: Uncomputation\n    qc = uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c)\n    \n    return qc, qr_b, qr_c, qr_a\n\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\n\nCode\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01\n\n\n\n\nCode\nhhl_circuit, qr_b, qr_c, qr_a = hhl_algorithm(mat_A, vec_b, n_c, t, C)\n\n# Add measurement\nc_b = ClassicalRegister(len(qr_b), name='cb')\nc_a = ClassicalRegister(1, name='ca')\nhhl_circuit.add_register(c_b, c_a)\nhhl_circuit.measure(qr_b, c_b)\nhhl_circuit.measure(qr_a, c_a)\n\nprint(\"Complete HHL Circuit:\")\nhhl_circuit.draw(output='mpl')\n\n\nComplete HHL Circuit:\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Execute HHL algorithm and analyze results\nsimulator = Aer.get_backend('statevector_simulator')\ntranspiled_circuit = transpile(hhl_circuit, simulator)\nresult = simulator.run(transpiled_circuit, shots=1000).result()\ncounts = result.get_counts(transpiled_circuit)\nprint(\"Raw measurement counts:\", counts)\n\n# Post-selection analysis\nmeasured_a1 = sum(counts[key] for key in counts if key[-1] == '1')\nmeasured_a0 = sum(counts[key] for key in counts if key[-1] == '0')\n\nif measured_a1 + measured_a0 &gt; 0:\n    print(f\"P(a=1) = {measured_a1 / (measured_a1 + measured_a0):.4f}\")\n    print(f\"P(a=0) = {measured_a0 / (measured_a1 + measured_a0):.4f}\")\n\n# Extract b-register states after post-selection\nfiltered_counts = {key[:-1]: count for key, count in counts.items() if key[-1] == '1'}\ntotal_valid = sum(filtered_counts.values())\n\nif total_valid &gt; 0:\n    print(\"\\nPost-selected b-register states (a=1):\")\n    for state, count in filtered_counts.items():\n        probability = count / total_valid\n        print(f\"|{state}⟩: {probability:.4f}\")\n\n\nRaw measurement counts: {'0 1': 1000}\nP(a=1) = 1.0000\nP(a=0) = 0.0000\n\nPost-selected b-register states (a=1):\n|0 ⟩: 1.0000\n\n\nprev Uncomputation"
  },
  {
    "objectID": "posts/machine_learning/11.hhl_imp5.html#introduction",
    "href": "posts/machine_learning/11.hhl_imp5.html#introduction",
    "title": "HHL Algorithm Implementation in Qiskit - Complete Version",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\nComplete HHL Implementation\n\n\n\nCode\n# Import necessary libraries\nimport qiskit\nimport numpy as np\nfrom numpy import pi\nfrom qiskit import ClassicalRegister, QuantumRegister, QuantumCircuit, transpile\nfrom qiskit_aer import Aer\nfrom qiskit.circuit.library import UnitaryGate, QFT, RYGate, MCXGate\nfrom scipy.linalg import expm\n\n# previous functions\ndef state_prep(mat_A, vec_b, n_c=1):\n  N_b = vec_b.shape[0]\n  n_b = int(np.log2(N_b))\n  qr_b = QuantumRegister(n_b, name='b')  # b-register\n  qr_c = QuantumRegister(n_c, name='c')  # c-register\n  qr_a = QuantumRegister(1, name='a')    # a-register\n  qc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n\n  norm_b = vec_b / np.linalg.norm(vec_b)\n  qc.initialize(norm_b, qr_b)\n  return qc, qr_b, qr_c, qr_a\n\ndef phase_estimation(qc, qr_b, qr_c, mat_A, t):\n    n_c = len(qr_c)\n    \n    # 1. Hadamard on c-register\n    qc.h(qr_c)\n    \n    # 2. Apply controlled-U^(2^j) operations\n    U = expm(1j * t * mat_A)  # 计算 e^(iAt)\n    U_gate = UnitaryGate(U, label=\"e^{iAt}\")  # 创建 U gate\n  \n    for j in range(n_c):\n        power = 2**j  # 计算 U^(2^j)\n        controlled_U_pow = U_gate.power(power).control(1)  # 控制操作\n        qc.append(controlled_U_pow, [qr_c[j], *qr_b]) \n    \n    # 3. Apply IQFT on c-register\n    iqft = QFT(num_qubits=n_c, do_swaps=False).inverse()\n    qc.append(iqft, qr_c)  # 作用于 c-register\n    \n    return qc\n\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\ndef uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c):\n    \"\"\"\n    Complete uncomputation phase (Phase 4) of HHL algorithm\n    \"\"\"\n    # Step 1: Apply QFT on c-register\n    qc.append(QFT(n_c, do_swaps=False), qr_c)\n    \n    # Step 2: Inverse controlled-U operations\n    U_inv = expm(-1j * t * mat_A)\n    U_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")\n    \n    for j in reversed(range(n_c)):\n        power = 2**j\n        controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n        qc.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n    \n    # Step 3: Apply Hadamard on c-register\n    qc.h(qr_c)\n    \n    return qc\n\n\n\n\nCode\ndef hhl_algorithm(mat_A, vec_b, n_c=1, t=np.pi/8, C=0.01):\n    \"\"\"\n    Complete HHL algorithm implementation\n    Returns: quantum circuit and registers\n    \"\"\"\n    # Phase 1: State Preparation\n    qc, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=n_c)\n    \n    # Phase 2: Quantum Phase Estimation\n    qc = phase_estimation(qc, qr_b, qr_c, mat_A, t)\n    \n    # Phase 3: Controlled Rotation\n    qc = controlled_rotation(qc, qr_c, qr_a, C, t, n_c)\n    \n    # Phase 4: Uncomputation\n    qc = uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c)\n    \n    return qc, qr_b, qr_c, qr_a\n\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\n\nCode\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01\n\n\n\n\nCode\nhhl_circuit, qr_b, qr_c, qr_a = hhl_algorithm(mat_A, vec_b, n_c, t, C)\n\n# Add measurement\nc_b = ClassicalRegister(len(qr_b), name='cb')\nc_a = ClassicalRegister(1, name='ca')\nhhl_circuit.add_register(c_b, c_a)\nhhl_circuit.measure(qr_b, c_b)\nhhl_circuit.measure(qr_a, c_a)\n\nprint(\"Complete HHL Circuit:\")\nhhl_circuit.draw(output='mpl')\n\n\nComplete HHL Circuit:\n\n\n\n\n\n\n\n\n\n\n\nCode\n# Execute HHL algorithm and analyze results\nsimulator = Aer.get_backend('statevector_simulator')\ntranspiled_circuit = transpile(hhl_circuit, simulator)\nresult = simulator.run(transpiled_circuit, shots=1000).result()\ncounts = result.get_counts(transpiled_circuit)\nprint(\"Raw measurement counts:\", counts)\n\n# Post-selection analysis\nmeasured_a1 = sum(counts[key] for key in counts if key[-1] == '1')\nmeasured_a0 = sum(counts[key] for key in counts if key[-1] == '0')\n\nif measured_a1 + measured_a0 &gt; 0:\n    print(f\"P(a=1) = {measured_a1 / (measured_a1 + measured_a0):.4f}\")\n    print(f\"P(a=0) = {measured_a0 / (measured_a1 + measured_a0):.4f}\")\n\n# Extract b-register states after post-selection\nfiltered_counts = {key[:-1]: count for key, count in counts.items() if key[-1] == '1'}\ntotal_valid = sum(filtered_counts.values())\n\nif total_valid &gt; 0:\n    print(\"\\nPost-selected b-register states (a=1):\")\n    for state, count in filtered_counts.items():\n        probability = count / total_valid\n        print(f\"|{state}⟩: {probability:.4f}\")\n\n\nRaw measurement counts: {'0 1': 1000}\nP(a=1) = 1.0000\nP(a=0) = 0.0000\n\nPost-selected b-register states (a=1):\n|0 ⟩: 1.0000\n\n\nprev Uncomputation"
  },
  {
    "objectID": "posts/machine_learning/09.hhl_imp3.html",
    "href": "posts/machine_learning/09.hhl_imp3.html",
    "title": "HHL Algorithm Implementation in Qiskit - Controlled Rotation & Measurement of the Ancilla Qubit",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\n*Controlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\\(C=0.01\\): a constant to pick, try to make \\(C\\) as large as possible while \\(-1\\leq\\frac{C}{\\tilde{\\lambda_j}} \\leq 1\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01\n\n\n\n\n\n\nThe Goal for this phase is to rotate the Acilla Qubit (register-a) based on the encoded eigenvalues in the c-register.\n\n\nCode\n# prepare the previous steps\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\n\n\n\n\nBegin with \\(|\\psi_4\\rangle\\): \\[\n|\\psi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle|0\\rangle_a\n\\] The next step is to rotate the ancilla qubit, \\(|0\\rangle_a\\), based on the encoded eigenvalues in the c-register. Such that \\(\\frac{1}{\\lambda_j}\\) is encoded in a-register.\nAfter apply the Control-Y rotation (\\(CR_y\\) Gate), we got \\(|\\psi_5\\rangle\\) \\[\n|\\psi_5\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\left(\\sqrt{1-\\frac{C^2}{\\tilde{\\lambda_j}^2}}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\right)\n\\]\nTherefore \\(\\psi_4\\xrightarrow{CR_y(\\theta_j)}\\psi_5\\)\n\n\n\n\n\n\nExpand for more about Controled Rotation\n\n\n\n\n\n\\[\nCR_y(\\theta_j)|c\\rangle|0\\rangle_a=\\begin{cases}|c\\rangle\\left(\\cos\\frac{\\theta_j}{2}|0\\rangle_a+\\sin\\frac{\\theta_j}{2}|1\\rangle_a\\right)&|c\\rangle=|1\\rangle\\\\|c\\rangle|0\\rangle_a&|c\\rangle=|0\\rangle\\end{cases}\n\\] Using the qubits in c-register as control qubits. (rotate if \\(|1\\rangle\\), do nothing if \\(|0\\rangle\\))\nThe rotated angle is \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\)\nThe \\(R_y(\\theta)\\) Gate is: \\[\nR_y(\\theta)=e^{-i\\frac{\\theta}{2}Y}=\\cos\\frac{\\theta}{2}I-i\\sin\\frac{\\theta}{2}Y=\\begin{bmatrix}\\cos\\frac{\\theta}{2}&-\\sin\\frac{\\theta}{2}\\\\\\sin\\frac{\\theta}{2}&\\cos\\frac{\\theta}{2}\\end{bmatrix}\n\\] Therefore, \\(R_y(\\theta)|0\\rangle_a=\\cos\\frac{\\theta}{2}|0\\rangle_a+\\sin\\frac{\\theta}{2}|1\\rangle_a\\)\nThe reason why \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\): What we want to store in a-register is \\(\\sin\\frac{\\theta_j}{2}=\\frac{C}{\\tilde{\\lambda_j}}\\)\nfrom Trigonometric, we know \\(\\cos^2(\\alpha)+\\sin^2(\\alpha)=1\\), therefore \\(\\cos(\\alpha)=\\sqrt{1-\\sin^2(\\alpha)}\\):\nfor any angle \\(\\alpha\\), where \\(\\alpha=\\arcsin(x)\\), means \\(\\sin(\\alpha)=x\\) (notice we have \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\), \\(\\sin\\left(\\frac{\\theta_j}{2}\\right)=\\frac{C}{\\tilde{\\lambda_j}}\\)) \\[\n\\cos(\\alpha)=\\sqrt{1-\\sin^2(\\alpha)}=\\sqrt{1-x^2}\n\\]\nsuch that \\(\\cos\\left(\\frac{\\theta_j}{2}\\right)=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}\\)\nApply the rotation Gate and \\(\\sin\\left(\\frac{\\theta_j}{2}\\right)=\\frac{C}{\\tilde{\\lambda_j}}\\) and \\(\\cos\\left(\\frac{\\theta_j}{2}\\right)=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}\\)\n\\[\n\\begin{align}\nR_y(\\theta_j)|0\\rangle_a=\\cos\\frac{\\theta_j}{2}|0\\rangle_a+\\sin\\frac{\\theta_j}{2}|1\\rangle_a \\\\\n\\Downarrow~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\\\nR_y(\\theta_j)|0\\rangle_a=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\n\\end{align}\n\\]\n\n\n实现思路 1. 遍历所有可能的二进制状态： - 对于 c-register 的 \\(n_c\\) 个量子比特，遍历所有可能的二进制状态 \\(k\\) (从 \\(1\\) 至 \\(2^{n_c}-1\\)) - 每个状态 \\(k\\) 对应一个 \\(\\phi=\\frac{k}{2^{n_c}}\\)，然后计算 \\(\\tilde{\\lambda_j}=\\frac{2\\pi\\phi}{t}\\)。\n\n计算旋转角度：\n\n\n根据 \\(\\tilde{\\lambda_j}\\) 计算旋转角度 \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\)\n\n\n应用受控旋转门：\n\n\n使用多控制\\(R_y\\)门（RYGate.control(n_qubits)）实现受控旋转。\n控制量子比特是 c-register 的量子比特，目标量子比特是 a-register 的辅助量子比特。\n\n\n恢复状态：\n\n在每次应用受控旋转门后，恢复 c-register 的状态，以便处理下一个二进制状态。\n\n\n\n\n\n\n\n\nCode\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\npsi_5 = psi_4.copy()\npsi_5 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\npsi_5.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nWhen the ancilla qubit is measured, the ancilla qubit wavefunction will collapse to either \\(|0\\rangle\\) or \\(|1\\rangle\\). If it is \\(|0\\rangle\\), the result will be discarded and the computation will be repeated until the measurement is \\(|1\\rangle\\). Therefore, the final wavefunction of interest is\nThe probability of getting \\(|1\\rangle_a\\) is \\(P_{|1\\rangle_a}=\\sum\\limits^{2^{n_b}-1}_{j=0}\\left|\\frac{Cb_j}{\\tilde{\\lambda_j}}\\right|^2\\), therefore, \\(\\psi_6\\) is: \\[\n|\\psi_6\\rangle=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\n\\]\n\nmeasure a-register\nonly keep when the measure result of a-register is \\(|1\\rangle_a\\).\n\n\n\nCode\n######## This takes too long to run, over 2 million loops\nimport sys\n\nsimulator = Aer.get_backend('statevector_simulator')\n\nres = 0\ncountloop = 0\nwhile (res&lt;1):\n  psi_5 = psi_4.copy()\n  psi_5 = controlled_rotation(psi_5, qr_c, qr_a, C=C, t=t, n_c=n_c)\n  psi_6 = psi_5.copy()\n  cr = ClassicalRegister(2, 'cr_1')\n  psi_6.add_register(cr)\n  psi_6.measure(qr_a[0], cr[0])\n  transpiled_circuit = transpile(psi_6, simulator)\n  result = simulator.run(transpiled_circuit, shots=1).result()\n  counts = result.get_counts(transpiled_circuit)\n    \n  countloop += 1\n  sys.stdout.write(f'\\r循环 {countloop} 次')  # `\\r` 覆盖前一行\n  sys.stdout.flush()  # 立即刷新输出\n\n  if '1' in counts:\n    res = 1\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\nExpand for more approaches tried.\n\n\n\n\n\n\n\nIn order to eliminate the possibility of \\(|0\\rangle_a\\). We are using control-Z gate and Grover Reflect gate here for Amplitude Amplification.\nControl-Z Gate: Flip the \\(|0\\rangle_a\\) (). But this gate does not change the amplitude. \\(Z|0\\rangle_a=-|0\\rangle_a\\) and \\(Z|1\\rangle_a=|1\\rangle_a\\). Therefore, \\(|\\psi_5\\rangle\\) becomes: \\[\n|\\psi_5'\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\left(-\\sqrt{1-\\frac{C^2}{\\tilde{\\lambda_j}^2}}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\right)\n\\]\nGrover Gate \\(U_{\\psi_5}=2|\\psi_5\\rangle\\langle\\psi_5|-I\\) \\(U_{\\psi_5}=HR_y(-2\\theta)H\\) A reverse rotation with angle is \\(-2\\theta\\) \\(\\text{Gover iteration time }\\approx\\frac{\\pi}{4}\\sqrt{N}\\), notice \\(N=2^{n_c}\\)\n\n\n\nCode\npsi_6 = psi_5.copy()\n\n# Step 1: 先应用 Controlled-Z\npsi_6.h(qr_a)\nmcz_gate = MCXGate(num_ctrl_qubits=n_c, ctrl_state='1' * n_c)  \npsi_6.append(mcz_gate, qr_c[:] + [qr_a[0]])\npsi_6.h(qr_a)\n\n# Step 2: Grover Diffusion Operator (放大 |1⟩_a)\nnum_iterations = 3  # 迭代 3 次\nfor _ in range(num_iterations):\n    # 1. 先对 `a-register` 施加 X，使 `|0⟩_a` 变 `|1⟩_a`\n    psi_6.x(qr_a)\n\n    # 2. H → Controlled-Z → H 实现均值反射\n    psi_6.h(qr_a)\n    psi_6.append(mcz_gate, qr_c[:] + [qr_a[0]])  # 再次施加 Controlled-Z\n    psi_6.h(qr_a)\n\n    # 3. 再次应用 X 恢复原态\n    psi_6.x(qr_a)\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\nCode\nfrom qiskit.quantum_info import Statevector\n\nsimulator = Aer.get_backend('statevector_simulator')\n\n# 复制 psi_5\npsi_6 = psi_5.copy()\n\n# 添加 classical register 以测量 a-register\n# cr = ClassicalRegister(2, 'cr_a')\n# psi_6.add_register(cr)\n\n# 仅测量 a-register\n# psi_6.measure(qr_a[0], cr[0])\n\n# 运行量子电路\nstatevector = Statevector.from_instruction(psi_6)\namplitudes = statevector.probabilities_dict()\n\n# **Post-selection: 仅保留 |1⟩_a**\nfiltered_amplitudes = {k: v for k, v in amplitudes.items() if k[-1] == '1'}\n\n# 归一化，使总概率变成 1\ntotal_prob = sum(filtered_amplitudes.values())\nnormalized_amplitudes = {k: v / total_prob for k, v in filtered_amplitudes.items()}\n\n# 输出 post-selection 结果\nprint(\"仅保留 |1⟩_a 的状态:\")\nfor state, prob in normalized_amplitudes.items():\n    print(f\"State {state}: {prob:.6f}\")\n\n# 重新构造 psi_6，使其 **只包含 |1⟩_a**\npsi_6 = Statevector(normalized_amplitudes)\n\n# 继续使用 psi_6 进行 ψ_7 → ψ_9 计算\npsi_6.draw(output='mpl')\n\n\n\n\n\nThe sequence of measure and uncompute does not matter. We can postpone the measure and discard step to the end.\n\n\nCode\npsi_6 = psi_5\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\n\n\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev Quantum Phase Estimation\nnext is Uncomputation"
  },
  {
    "objectID": "posts/machine_learning/09.hhl_imp3.html#introduction",
    "href": "posts/machine_learning/09.hhl_imp3.html#introduction",
    "title": "HHL Algorithm Implementation in Qiskit - Controlled Rotation & Measurement of the Ancilla Qubit",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\n*Controlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\\(C=0.01\\): a constant to pick, try to make \\(C\\) as large as possible while \\(-1\\leq\\frac{C}{\\tilde{\\lambda_j}} \\leq 1\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01"
  },
  {
    "objectID": "posts/machine_learning/09.hhl_imp3.html#phase-3-controlled-rotation-measurement-of-the-ancilla-qubit",
    "href": "posts/machine_learning/09.hhl_imp3.html#phase-3-controlled-rotation-measurement-of-the-ancilla-qubit",
    "title": "HHL Algorithm Implementation in Qiskit - Controlled Rotation & Measurement of the Ancilla Qubit",
    "section": "",
    "text": "The Goal for this phase is to rotate the Acilla Qubit (register-a) based on the encoded eigenvalues in the c-register.\n\n\nCode\n# prepare the previous steps\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\n\n\n\n\nBegin with \\(|\\psi_4\\rangle\\): \\[\n|\\psi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle|0\\rangle_a\n\\] The next step is to rotate the ancilla qubit, \\(|0\\rangle_a\\), based on the encoded eigenvalues in the c-register. Such that \\(\\frac{1}{\\lambda_j}\\) is encoded in a-register.\nAfter apply the Control-Y rotation (\\(CR_y\\) Gate), we got \\(|\\psi_5\\rangle\\) \\[\n|\\psi_5\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\left(\\sqrt{1-\\frac{C^2}{\\tilde{\\lambda_j}^2}}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\right)\n\\]\nTherefore \\(\\psi_4\\xrightarrow{CR_y(\\theta_j)}\\psi_5\\)\n\n\n\n\n\n\nExpand for more about Controled Rotation\n\n\n\n\n\n\\[\nCR_y(\\theta_j)|c\\rangle|0\\rangle_a=\\begin{cases}|c\\rangle\\left(\\cos\\frac{\\theta_j}{2}|0\\rangle_a+\\sin\\frac{\\theta_j}{2}|1\\rangle_a\\right)&|c\\rangle=|1\\rangle\\\\|c\\rangle|0\\rangle_a&|c\\rangle=|0\\rangle\\end{cases}\n\\] Using the qubits in c-register as control qubits. (rotate if \\(|1\\rangle\\), do nothing if \\(|0\\rangle\\))\nThe rotated angle is \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\)\nThe \\(R_y(\\theta)\\) Gate is: \\[\nR_y(\\theta)=e^{-i\\frac{\\theta}{2}Y}=\\cos\\frac{\\theta}{2}I-i\\sin\\frac{\\theta}{2}Y=\\begin{bmatrix}\\cos\\frac{\\theta}{2}&-\\sin\\frac{\\theta}{2}\\\\\\sin\\frac{\\theta}{2}&\\cos\\frac{\\theta}{2}\\end{bmatrix}\n\\] Therefore, \\(R_y(\\theta)|0\\rangle_a=\\cos\\frac{\\theta}{2}|0\\rangle_a+\\sin\\frac{\\theta}{2}|1\\rangle_a\\)\nThe reason why \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\): What we want to store in a-register is \\(\\sin\\frac{\\theta_j}{2}=\\frac{C}{\\tilde{\\lambda_j}}\\)\nfrom Trigonometric, we know \\(\\cos^2(\\alpha)+\\sin^2(\\alpha)=1\\), therefore \\(\\cos(\\alpha)=\\sqrt{1-\\sin^2(\\alpha)}\\):\nfor any angle \\(\\alpha\\), where \\(\\alpha=\\arcsin(x)\\), means \\(\\sin(\\alpha)=x\\) (notice we have \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\), \\(\\sin\\left(\\frac{\\theta_j}{2}\\right)=\\frac{C}{\\tilde{\\lambda_j}}\\)) \\[\n\\cos(\\alpha)=\\sqrt{1-\\sin^2(\\alpha)}=\\sqrt{1-x^2}\n\\]\nsuch that \\(\\cos\\left(\\frac{\\theta_j}{2}\\right)=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}\\)\nApply the rotation Gate and \\(\\sin\\left(\\frac{\\theta_j}{2}\\right)=\\frac{C}{\\tilde{\\lambda_j}}\\) and \\(\\cos\\left(\\frac{\\theta_j}{2}\\right)=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}\\)\n\\[\n\\begin{align}\nR_y(\\theta_j)|0\\rangle_a=\\cos\\frac{\\theta_j}{2}|0\\rangle_a+\\sin\\frac{\\theta_j}{2}|1\\rangle_a \\\\\n\\Downarrow~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\\\\\nR_y(\\theta_j)|0\\rangle_a=\\sqrt{1-\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)^2}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\n\\end{align}\n\\]\n\n\n实现思路 1. 遍历所有可能的二进制状态： - 对于 c-register 的 \\(n_c\\) 个量子比特，遍历所有可能的二进制状态 \\(k\\) (从 \\(1\\) 至 \\(2^{n_c}-1\\)) - 每个状态 \\(k\\) 对应一个 \\(\\phi=\\frac{k}{2^{n_c}}\\)，然后计算 \\(\\tilde{\\lambda_j}=\\frac{2\\pi\\phi}{t}\\)。\n\n计算旋转角度：\n\n\n根据 \\(\\tilde{\\lambda_j}\\) 计算旋转角度 \\(\\theta_j=2\\arcsin\\left(\\frac{C}{\\tilde{\\lambda_j}}\\right)\\)\n\n\n应用受控旋转门：\n\n\n使用多控制\\(R_y\\)门（RYGate.control(n_qubits)）实现受控旋转。\n控制量子比特是 c-register 的量子比特，目标量子比特是 a-register 的辅助量子比特。\n\n\n恢复状态：\n\n在每次应用受控旋转门后，恢复 c-register 的状态，以便处理下一个二进制状态。\n\n\n\n\n\n\n\n\nCode\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\npsi_5 = psi_4.copy()\npsi_5 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\npsi_5.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nWhen the ancilla qubit is measured, the ancilla qubit wavefunction will collapse to either \\(|0\\rangle\\) or \\(|1\\rangle\\). If it is \\(|0\\rangle\\), the result will be discarded and the computation will be repeated until the measurement is \\(|1\\rangle\\). Therefore, the final wavefunction of interest is\nThe probability of getting \\(|1\\rangle_a\\) is \\(P_{|1\\rangle_a}=\\sum\\limits^{2^{n_b}-1}_{j=0}\\left|\\frac{Cb_j}{\\tilde{\\lambda_j}}\\right|^2\\), therefore, \\(\\psi_6\\) is: \\[\n|\\psi_6\\rangle=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\n\\]\n\nmeasure a-register\nonly keep when the measure result of a-register is \\(|1\\rangle_a\\).\n\n\n\nCode\n######## This takes too long to run, over 2 million loops\nimport sys\n\nsimulator = Aer.get_backend('statevector_simulator')\n\nres = 0\ncountloop = 0\nwhile (res&lt;1):\n  psi_5 = psi_4.copy()\n  psi_5 = controlled_rotation(psi_5, qr_c, qr_a, C=C, t=t, n_c=n_c)\n  psi_6 = psi_5.copy()\n  cr = ClassicalRegister(2, 'cr_1')\n  psi_6.add_register(cr)\n  psi_6.measure(qr_a[0], cr[0])\n  transpiled_circuit = transpile(psi_6, simulator)\n  result = simulator.run(transpiled_circuit, shots=1).result()\n  counts = result.get_counts(transpiled_circuit)\n    \n  countloop += 1\n  sys.stdout.write(f'\\r循环 {countloop} 次')  # `\\r` 覆盖前一行\n  sys.stdout.flush()  # 立即刷新输出\n\n  if '1' in counts:\n    res = 1\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\nExpand for more approaches tried.\n\n\n\n\n\n\n\nIn order to eliminate the possibility of \\(|0\\rangle_a\\). We are using control-Z gate and Grover Reflect gate here for Amplitude Amplification.\nControl-Z Gate: Flip the \\(|0\\rangle_a\\) (). But this gate does not change the amplitude. \\(Z|0\\rangle_a=-|0\\rangle_a\\) and \\(Z|1\\rangle_a=|1\\rangle_a\\). Therefore, \\(|\\psi_5\\rangle\\) becomes: \\[\n|\\psi_5'\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\left(-\\sqrt{1-\\frac{C^2}{\\tilde{\\lambda_j}^2}}|0\\rangle_a+\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\right)\n\\]\nGrover Gate \\(U_{\\psi_5}=2|\\psi_5\\rangle\\langle\\psi_5|-I\\) \\(U_{\\psi_5}=HR_y(-2\\theta)H\\) A reverse rotation with angle is \\(-2\\theta\\) \\(\\text{Gover iteration time }\\approx\\frac{\\pi}{4}\\sqrt{N}\\), notice \\(N=2^{n_c}\\)\n\n\n\nCode\npsi_6 = psi_5.copy()\n\n# Step 1: 先应用 Controlled-Z\npsi_6.h(qr_a)\nmcz_gate = MCXGate(num_ctrl_qubits=n_c, ctrl_state='1' * n_c)  \npsi_6.append(mcz_gate, qr_c[:] + [qr_a[0]])\npsi_6.h(qr_a)\n\n# Step 2: Grover Diffusion Operator (放大 |1⟩_a)\nnum_iterations = 3  # 迭代 3 次\nfor _ in range(num_iterations):\n    # 1. 先对 `a-register` 施加 X，使 `|0⟩_a` 变 `|1⟩_a`\n    psi_6.x(qr_a)\n\n    # 2. H → Controlled-Z → H 实现均值反射\n    psi_6.h(qr_a)\n    psi_6.append(mcz_gate, qr_c[:] + [qr_a[0]])  # 再次施加 Controlled-Z\n    psi_6.h(qr_a)\n\n    # 3. 再次应用 X 恢复原态\n    psi_6.x(qr_a)\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\nCode\nfrom qiskit.quantum_info import Statevector\n\nsimulator = Aer.get_backend('statevector_simulator')\n\n# 复制 psi_5\npsi_6 = psi_5.copy()\n\n# 添加 classical register 以测量 a-register\n# cr = ClassicalRegister(2, 'cr_a')\n# psi_6.add_register(cr)\n\n# 仅测量 a-register\n# psi_6.measure(qr_a[0], cr[0])\n\n# 运行量子电路\nstatevector = Statevector.from_instruction(psi_6)\namplitudes = statevector.probabilities_dict()\n\n# **Post-selection: 仅保留 |1⟩_a**\nfiltered_amplitudes = {k: v for k, v in amplitudes.items() if k[-1] == '1'}\n\n# 归一化，使总概率变成 1\ntotal_prob = sum(filtered_amplitudes.values())\nnormalized_amplitudes = {k: v / total_prob for k, v in filtered_amplitudes.items()}\n\n# 输出 post-selection 结果\nprint(\"仅保留 |1⟩_a 的状态:\")\nfor state, prob in normalized_amplitudes.items():\n    print(f\"State {state}: {prob:.6f}\")\n\n# 重新构造 psi_6，使其 **只包含 |1⟩_a**\npsi_6 = Statevector(normalized_amplitudes)\n\n# 继续使用 psi_6 进行 ψ_7 → ψ_9 计算\npsi_6.draw(output='mpl')\n\n\n\n\n\nThe sequence of measure and uncompute does not matter. We can postpone the measure and discard step to the end.\n\n\nCode\npsi_6 = psi_5\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef controlled_rotation(qc, qr_c, qr_a, C, t, n_c):\n    \"\"\"\n    实现受控旋转门，作用于 a-register，基于 c-register 的相位估计结果\n    :param qc: 量子电路（需已经过相位估计到 |psi_4&gt; 状态）\n    :param qr_c: c-register（存储相位估计结果）\n    :param qr_a: a-register（辅助比特）\n    :param C: 缩放常数\n    :param t: 时间参数（用于计算真实特征值）\n    :param n_c: c-register 的量子比特数\n    \"\"\"\n    # 遍历所有可能的相位估计结果 k（从1到2^n_c -1）\n    for k in range(1, 2**n_c):\n        # Step 1: 将二进制状态k转换为控制条件（设置X门）\n        # 保存需要翻转的量子比特索引\n        flip_qubits = []\n        for i in range(n_c):\n            if (k & (1 &lt;&lt; i)) == 0:  # 如果第i位是0，需要翻转\n                qc.x(qr_c[i])\n                flip_qubits.append(i)\n        \n        # Step 2: 计算旋转角度 theta_j\n        # 计算相位 phi（注意处理补码）\n        phi = k / (2**n_c)\n        if k &gt; 2**(n_c - 1):\n            phi -= 1.0  # 处理负相位（二进制补码）\n        \n        # 计算真实特征值 lambda_j = (2π / t) * phi\n        lambda_j = (2 * np.pi / t) * phi\n        \n        # 计算旋转角度 theta_j = 2*arcsin(C / lambda_j)\n        if abs(lambda_j) &gt; 1e-8:  # 避免除以零\n            theta_j = 2 * np.arcsin(C / lambda_j)\n        else:\n            theta_j = 0  # 若lambda_j太小，跳过旋转\n        \n        # Step 3: 应用多控制 RY 门到 a-register\n        if abs(theta_j) &gt; 1e-8:  # 仅当角度有效时应用\n            ry_gate = RYGate(theta_j).control(num_ctrl_qubits=n_c, ctrl_state='1'*n_c)\n            qc.append(ry_gate, qr_c[:] + [qr_a[0]])\n        \n        # Step 4: 恢复被翻转的量子比特\n        for i in flip_qubits:\n            qc.x(qr_c[i])\n\n    return qc\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\n\n\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\npsi_6.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev Quantum Phase Estimation\nnext is Uncomputation"
  },
  {
    "objectID": "posts/machine_learning/07.hhl_imp1.html",
    "href": "posts/machine_learning/07.hhl_imp1.html",
    "title": "HHL Algorithm Implementation in Qiskit - State Preparation",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\n*State Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\n\n\n\n\n\n\n\\(A\\vec{x}=\\vec{b}~~\\rightarrow~~\\vec{x}=A^{-1}\\vec{b}\\)\nThe goal is to get \\(\\vec{x}\\)\n\\(|x\\rangle = A^{-1}|b\\rangle=\\sum\\limits^{N-1}_{j=0}b_jA^{-1}|u_j\\rangle=\\sum\\limits^{N-1}_{j=0}\\frac{b_j}{\\lambda_j}|u_j\\rangle\\) \\[\n\\begin{aligned}\n&~~~~~~A|u_j\\rangle = \\lambda_j|u_j\\rangle \\\\\n&\\rightarrow A^{-1}A|u_j\\rangle = A^{-1}\\lambda_j|u_j\\rangle \\\\\n&\\rightarrow |u_j\\rangle = A^{-1}\\lambda_j|u_j\\rangle \\\\\n&\\rightarrow A^{-1}|u_j\\rangle = \\frac{1}{\\lambda_j}|u_j\\rangle\n\\end{aligned}\n\\]\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\neigenvalue and eigenvecter\n\n\n\nCode\nA = np.array([[1, -1/3], [-1/3, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(f\"eigenvalues:\\n{np.round(eigenvalues,2)}\")\nprint(f\"eigenvectors:\\n{np.round(eigenvectors,2)}\")\n\n# Verify the eigenvalue-eigenvector relationship\nassert np.allclose(np.dot(A, eigenvectors.T[0]), eigenvalues[0] * eigenvectors.T[0])\nassert np.allclose(np.dot(A, eigenvectors.T[1]), eigenvalues[1] * eigenvectors.T[1])\n\n\neigenvalues:\n[1.33 0.67]\neigenvectors:\n[[ 0.71  0.71]\n [-0.71  0.71]]\n\n\n\n\nCode\n### The eigenvalue and eigenvectors given by paper\nA = np.array([[1, -1/3], [-1/3, 1]])\nb = np.array([0,1])\neigenvalues = [2/3, 4/3]\neigenvectors = np.array([[-1/(2**0.5), -1/(2**0.5)],[-1/(2**0.5), 1/(2**0.5)]])\n\nassert np.allclose(np.dot(A, eigenvectors.T[0]), eigenvalues[0] * eigenvectors.T[0])\nassert np.allclose(np.dot(A, eigenvectors.T[1]), eigenvalues[1] * eigenvectors.T[1])\n\n\nTherefore, the eigenvectors are \\(\\vec{u_0}=\\begin{bmatrix}-\\frac{1}{\\sqrt2}\\\\-\\frac{1}{\\sqrt2}\\end{bmatrix}\\) and \\(\\vec{u_1}=\\begin{bmatrix}-\\frac{1}{\\sqrt2}\\\\\\frac{1}{\\sqrt2}\\end{bmatrix}\\) The eigenvalues are \\(\\lambda_0=\\frac{2}{3}\\), \\(\\lambda_1=\\frac{4}{3}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\n\n\n\n\n\n\\(A\\) is \\(N_b \\times N_b\\) Hermitian matrix\nHHL is \\(O(\\log(N))\\)\n\n\n\n\n\n\nGiven \\(n_b\\), \\(n_c\\), there are total \\(n_b+n_c+1\\) qubits \\[\n\\begin{align}\n|\\psi_0\\rangle &= |0\\dots0\\rangle_b|0\\dots0\\rangle_c|0\\rangle_a \\\\\n&= |0\\rangle^{\\otimes n_b}|0\\rangle^{\\otimes n}|0\\rangle\n\\end{align}\n\\]\n\n\nCode\nfrom qiskit import QuantumRegister, QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nqr_b = QuantumRegister(n_b, name='qr_b')  # b-register\nqr_c = QuantumRegister(n_c, name='qr_c')  # c-register\nqr_a = QuantumRegister(1, name='qr_a')    # a-register\nqc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n# Initialize the quantum circuitz\nprint(\"Initial quantum circuit:\")\n# print(qc.draw(output='text'))\nqc.draw(output='mpl')\n# latex_source = qc.draw(output='latex_source')\n# print(latex_source)\n\n\nInitial quantum circuit:\n\n\n\n\n\n\n\n\n\n\n\n\nIn the state preparation, \\(|0\\dots 0\\rangle_b\\) in the b-register needs to be rotated to have the amplitudes correspond to the coefficients of \\(\\vec{b}\\). \\(\\vec{b}=\\left(\\begin{matrix}\\beta_0\\\\\\beta_1\\\\\\vdots\\\\\\beta_{N_b-1}\\end{matrix}\\right)\\Leftrightarrow\\beta_0|0\\rangle+\\beta_1|1\\rangle+\\dots+\\beta_{N_b-1}|N_b-1\\rangle=|b\\rangle\\) \\(|\\psi_1\\rangle=|b\\rangle_b|0\\dots0\\rangle_c|0\\rangle_a\\)\n\n\nCode\n# normalize b to make sure the aggregate possibility is 1\nnorm_b = b / np.linalg.norm(b)\nqc.initialize(norm_b, qr_b)  # Apply to b-register\n\n\n#----------Print states--------------------------------\n# Simulate the circuit\nsimulator = Aer.get_backend('statevector_simulator')\n\n# Transpile the circuit for the simulator\ntranspiled_circuit = transpile(qc, simulator)\n\n# Run the transpiled circuit\nresult = simulator.run(transpiled_circuit).result()\n\n# Extract the statevector\nstatevector = result.get_statevector(qc)\nprint(\"Statevector after initialization:\", statevector)\n\n# Optional: Visualize the circuit (if needed)\nqc.draw(output='mpl')\n\n#----------Print states--------------------------------\n\n\nStatevector after initialization: Statevector([0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n             0.+0.j],\n            dims=(2, 2, 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef state_prep(mat_A, vec_b, n_c=1):\n  N_b = vec_b.shape[0]\n  n_b = int(np.log2(N_b))\n  qr_b = QuantumRegister(n_b, name='qr_b')  # b-register\n  qr_c = QuantumRegister(n_c, name='qr_c')  # c-register\n  qr_a = QuantumRegister(1, name='qr_a')    # a-register\n  qc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n\n  norm_b = vec_b / np.linalg.norm(vec_b)\n  qc.initialize(norm_b, qr_b)\n  return qc, qr_b, qr_c, qr_a\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\n\npsi_1, *_= state_prep(mat_A, vec_b, n_c=1)\npsi_1.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nnext step is Quantum Phase Estimation"
  },
  {
    "objectID": "posts/machine_learning/07.hhl_imp1.html#introduction",
    "href": "posts/machine_learning/07.hhl_imp1.html#introduction",
    "title": "HHL Algorithm Implementation in Qiskit - State Preparation",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\n*State Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)"
  },
  {
    "objectID": "posts/machine_learning/07.hhl_imp1.html#phase-0-environment-setup",
    "href": "posts/machine_learning/07.hhl_imp1.html#phase-0-environment-setup",
    "title": "HHL Algorithm Implementation in Qiskit - State Preparation",
    "section": "",
    "text": "\\(A\\vec{x}=\\vec{b}~~\\rightarrow~~\\vec{x}=A^{-1}\\vec{b}\\)\nThe goal is to get \\(\\vec{x}\\)\n\\(|x\\rangle = A^{-1}|b\\rangle=\\sum\\limits^{N-1}_{j=0}b_jA^{-1}|u_j\\rangle=\\sum\\limits^{N-1}_{j=0}\\frac{b_j}{\\lambda_j}|u_j\\rangle\\) \\[\n\\begin{aligned}\n&~~~~~~A|u_j\\rangle = \\lambda_j|u_j\\rangle \\\\\n&\\rightarrow A^{-1}A|u_j\\rangle = A^{-1}\\lambda_j|u_j\\rangle \\\\\n&\\rightarrow |u_j\\rangle = A^{-1}\\lambda_j|u_j\\rangle \\\\\n&\\rightarrow A^{-1}|u_j\\rangle = \\frac{1}{\\lambda_j}|u_j\\rangle\n\\end{aligned}\n\\]\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\neigenvalue and eigenvecter\n\n\n\nCode\nA = np.array([[1, -1/3], [-1/3, 1]])\neigenvalues, eigenvectors = np.linalg.eig(A)\nprint(f\"eigenvalues:\\n{np.round(eigenvalues,2)}\")\nprint(f\"eigenvectors:\\n{np.round(eigenvectors,2)}\")\n\n# Verify the eigenvalue-eigenvector relationship\nassert np.allclose(np.dot(A, eigenvectors.T[0]), eigenvalues[0] * eigenvectors.T[0])\nassert np.allclose(np.dot(A, eigenvectors.T[1]), eigenvalues[1] * eigenvectors.T[1])\n\n\neigenvalues:\n[1.33 0.67]\neigenvectors:\n[[ 0.71  0.71]\n [-0.71  0.71]]\n\n\n\n\nCode\n### The eigenvalue and eigenvectors given by paper\nA = np.array([[1, -1/3], [-1/3, 1]])\nb = np.array([0,1])\neigenvalues = [2/3, 4/3]\neigenvectors = np.array([[-1/(2**0.5), -1/(2**0.5)],[-1/(2**0.5), 1/(2**0.5)]])\n\nassert np.allclose(np.dot(A, eigenvectors.T[0]), eigenvalues[0] * eigenvectors.T[0])\nassert np.allclose(np.dot(A, eigenvectors.T[1]), eigenvalues[1] * eigenvectors.T[1])\n\n\nTherefore, the eigenvectors are \\(\\vec{u_0}=\\begin{bmatrix}-\\frac{1}{\\sqrt2}\\\\-\\frac{1}{\\sqrt2}\\end{bmatrix}\\) and \\(\\vec{u_1}=\\begin{bmatrix}-\\frac{1}{\\sqrt2}\\\\\\frac{1}{\\sqrt2}\\end{bmatrix}\\) The eigenvalues are \\(\\lambda_0=\\frac{2}{3}\\), \\(\\lambda_1=\\frac{4}{3}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\n\n\n\n\n\n\\(A\\) is \\(N_b \\times N_b\\) Hermitian matrix\nHHL is \\(O(\\log(N))\\)"
  },
  {
    "objectID": "posts/machine_learning/07.hhl_imp1.html#phase-1-state-preparation",
    "href": "posts/machine_learning/07.hhl_imp1.html#phase-1-state-preparation",
    "title": "HHL Algorithm Implementation in Qiskit - State Preparation",
    "section": "",
    "text": "Given \\(n_b\\), \\(n_c\\), there are total \\(n_b+n_c+1\\) qubits \\[\n\\begin{align}\n|\\psi_0\\rangle &= |0\\dots0\\rangle_b|0\\dots0\\rangle_c|0\\rangle_a \\\\\n&= |0\\rangle^{\\otimes n_b}|0\\rangle^{\\otimes n}|0\\rangle\n\\end{align}\n\\]\n\n\nCode\nfrom qiskit import QuantumRegister, QuantumCircuit, transpile\nfrom qiskit_aer import Aer\n\nqr_b = QuantumRegister(n_b, name='qr_b')  # b-register\nqr_c = QuantumRegister(n_c, name='qr_c')  # c-register\nqr_a = QuantumRegister(1, name='qr_a')    # a-register\nqc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n# Initialize the quantum circuitz\nprint(\"Initial quantum circuit:\")\n# print(qc.draw(output='text'))\nqc.draw(output='mpl')\n# latex_source = qc.draw(output='latex_source')\n# print(latex_source)\n\n\nInitial quantum circuit:\n\n\n\n\n\n\n\n\n\n\n\n\nIn the state preparation, \\(|0\\dots 0\\rangle_b\\) in the b-register needs to be rotated to have the amplitudes correspond to the coefficients of \\(\\vec{b}\\). \\(\\vec{b}=\\left(\\begin{matrix}\\beta_0\\\\\\beta_1\\\\\\vdots\\\\\\beta_{N_b-1}\\end{matrix}\\right)\\Leftrightarrow\\beta_0|0\\rangle+\\beta_1|1\\rangle+\\dots+\\beta_{N_b-1}|N_b-1\\rangle=|b\\rangle\\) \\(|\\psi_1\\rangle=|b\\rangle_b|0\\dots0\\rangle_c|0\\rangle_a\\)\n\n\nCode\n# normalize b to make sure the aggregate possibility is 1\nnorm_b = b / np.linalg.norm(b)\nqc.initialize(norm_b, qr_b)  # Apply to b-register\n\n\n#----------Print states--------------------------------\n# Simulate the circuit\nsimulator = Aer.get_backend('statevector_simulator')\n\n# Transpile the circuit for the simulator\ntranspiled_circuit = transpile(qc, simulator)\n\n# Run the transpiled circuit\nresult = simulator.run(transpiled_circuit).result()\n\n# Extract the statevector\nstatevector = result.get_statevector(qc)\nprint(\"Statevector after initialization:\", statevector)\n\n# Optional: Visualize the circuit (if needed)\nqc.draw(output='mpl')\n\n#----------Print states--------------------------------\n\n\nStatevector after initialization: Statevector([0.+0.j, 0.+0.j, 1.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,\n             0.+0.j],\n            dims=(2, 2, 2))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef state_prep(mat_A, vec_b, n_c=1):\n  N_b = vec_b.shape[0]\n  n_b = int(np.log2(N_b))\n  qr_b = QuantumRegister(n_b, name='qr_b')  # b-register\n  qr_c = QuantumRegister(n_c, name='qr_c')  # c-register\n  qr_a = QuantumRegister(1, name='qr_a')    # a-register\n  qc = QuantumCircuit(qr_c, qr_b, qr_a)  # complete circuit\n\n  norm_b = vec_b / np.linalg.norm(vec_b)\n  qc.initialize(norm_b, qr_b)\n  return qc, qr_b, qr_c, qr_a\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\n\npsi_1, *_= state_prep(mat_A, vec_b, n_c=1)\npsi_1.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nnext step is Quantum Phase Estimation"
  },
  {
    "objectID": "posts/machine_learning/08.hhl_imp2.html",
    "href": "posts/machine_learning/08.hhl_imp2.html",
    "title": "HHL Algorithm Implementation in Qiskit - Quantum Phase Estimation (QPE)",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\n*Quantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, choose \\(t\\) such that \\(\\tilde{\\lambda_j}=\\frac{\\lambda_jt}{2\\pi}\\) is an integer\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\n\n\n\n\n\n\nThe Goal for this phase is to estimate the eigenvalues of given Matrix.\n\n\n\\[\n\\begin{align}\n|\\psi_2\\rangle &= I^{\\otimes n_b}\\otimes H^{\\otimes n}\\otimes I |\\psi_1\\rangle \\\\\n&= |b\\rangle\\frac{1}{2^\\frac{n}{2}}(|0\\rangle+|1\\rangle)^{\\otimes n}|0\\rangle \\\\\n&= |b\\rangle\\frac{1}{\\sqrt2 ^n}(|0\\rangle+|1\\rangle)^{\\otimes n}|0\\rangle\n\\end{align}\n\\]\n其实就是每个state in c-register 都apply Hadamard gate (变成\\(\\frac{1}{\\sqrt2}(|0\\rangle+|1\\rangle)\\)) \\(\\frac{1}{\\sqrt2 ^ n}\\) 是因为\\(H^{\\otimes n_c}|0\\dots0\\rangle_c\\)\n\n\nCode\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_2 = psi_1.copy()\npsi_2.h(qr_c)\npsi_2.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nApply the control-\\(U\\) operation such that the eigenvalues of A would be stored in register-C. \\[\nU = e^{iAt}\n\\] Where \\(t\\) is the time. E.g. a state \\(|\\psi\\rangle\\) would be \\(e^{iAt}|\\psi\\rangle\\) after time \\(t\\).\nWe want to apply the control-\\(U\\) operation such that \\(U|b\\rangle = e^{2\\pi i \\phi}|b\\rangle\\), where \\(e^{2\\pi i \\phi}\\) is the eigenvalue of A (\\(A|\\phi\\rangle=e^{2\\pi i \\phi}|\\phi\\rangle\\)), esitmated from \\(U^{2r}, U=e^{iAt}\\). Where \\(r\\) is the index of the clock qubit (c-register). \nWhen the control clock qubit is \\(|0\\rangle\\), \\(|b\\rangle\\) will not be affected. If the clock bit is \\(|1\\rangle\\), \\(U\\) will be applied to \\(|b\\rangle\\). This is equivalent to multiplying \\(e^{2\\pi i \\phi 2^j}\\) in front of the \\(|1\\rangle\\) of the j-th clock qubit \\(|c_j\\rangle\\). (notice the \\(U^{2^r}\\) and \\(U^k\\) ahead, here \\(2j=2r\\) or \\(2j=k\\))\n\n\n\n受控 \\(U^{2^j}\\) 操作的目的是把 \\(e^{i\\lambda_i \\phi}\\) 编码到控制寄存器，通过 QFT 解析出 \\(\\lambda_i\\) 的相位信息。\n\\(e^{iAt}\\) 是时间演化矩阵，而我们希望将其转换成 \\(e^{2\\pi i \\phi}\\)， 使得 QFT 可以处理相位信息并测量出 \\(\\phi\\)。\n指数幂次 \\(U^{2^j}\\) 的目的是让相位信息能以足够高的分辨率存入控制寄存器，从而精确估计 \\(\\lambda_i\\)。\n最终，\\(\\lambda_i=\\frac{2\\pi\\phi}{t}\\)，通过控制寄存器的测量结果 \\(\\phi\\) 来反推出 \\(\\lambda_i\\)。\n\nafter controlled-\\(U\\) operation, we have \\[\n|\\psi_3\\rangle=|b\\rangle\\otimes\\frac{1}{\\sqrt2 ^n}~~~(|0\\rangle+e^{2\\pi i \\phi 2^{n-1}}|1\\rangle)\\otimes(|0\\rangle+e^{2\\pi i \\phi 2^{n-2}}|1\\rangle)\\otimes\\dots~~~\\otimes(|0\\rangle+e^{2\\pi i \\phi 2^{0}}|1\\rangle)\\otimes|0\\rangle_a\n\\] \\[\n|\\psi_3\\rangle=|b\\rangle \\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^{n}-1}_{k=0}e^{2\\pi i \\phi k}|k\\rangle |0\\rangle_a\n\\]\n\n\nCode\nU = expm(1j * t * mat_A)\nU_gate = UnitaryGate(U, label=\"e^\\{iAt\\}\")\ncontrolled_U = U_gate.control(1)  # controled gate by |1⟩\npsi_3 = psi_2.copy()\nfor j in range(n_c):\n    power = 2**j  # U^{2^j}\n    controlled_U_pow = U_gate.power(power).control(1)  # 计算 U^{2^j} 并加控制\n    psi_3.append(controlled_U_pow, [qr_c[j], *qr_b])\n\n\npsi_3.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\nApply IQFT, only clock qubits (c-register) are affected.\n\\[\n\\begin{align}\n|\\psi_4\\rangle &= |b\\rangle\\text{IQFT}(\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^{n}-1}_{k=0})|0\\rangle_a\\\\\n&=|b\\rangle\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i \\phi k}(\\text{IQFT}|k\\rangle)|0\\rangle_a\\\\\n&=|b\\rangle\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i \\phi k}(\\sum\\limits^{2^n-1}_{y=0}e^{-2\\pi iyk/N}|y\\rangle)|0\\rangle_a\\\\\n&=\\frac{1}{\\sqrt2 ^n}|b\\rangle\\sum\\limits^{2^n-1}_{y=0}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i k (\\phi-y/N)}|y\\rangle|0\\rangle_a\n\\end{align}\n\\]\nonly \\(|y\\rangle\\) satisfying the condition \\(\\phi-y/N=0\\) will have a finite amplitude of \\(\\sum\\limits^{2^n-1}_{k=0}e^0=2^n\\) otherwise the amplitude is \\(\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi ik(\\phi-y/N)}=0\\). After ignoring the states of zero amplitude\n\\[\\begin{align}\n|\\psi_4\\rangle&=\\frac{1}{\\sqrt2 ^n}|b\\rangle\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi ik.0}|N\\phi\\rangle|0\\rangle_a\\\\\n&=|b\\rangle|N\\phi\\rangle|0\\rangle_a\n\\end{align}\n\\]\nTherefore, in QPE, the clock qubits are used to represent the phase information of \\(U\\), which is \\(\\phi\\), and the accuracy depends on the number of qubits, \\(n\\).\nTo understand why the c-register is called the clock qubits and the meaning of t better, it is worth noting that the Hamiltonian of a system in quantum mechanics determines how a system evolves through the following equation,\\(U=e^{iAt}\\), and \\(t\\) can be treated as the evolution time for that Hamiltonian.\n\\(U\\) is also diagonal in \\(A\\)′s eigenvector, \\(|u_i\\rangle\\), basis. If \\(|b\\rangle=|u_j\\rangle\\).\\(U|b\\rangle=e^{i\\lambda_jt}|u_j\\rangle\\).\nlet \\(i\\lambda_jt=2\\pi i \\phi\\), we get \\(\\phi=\\frac{\\lambda_j t}{2\\pi}\\), and \\[\n|\\psi_4\\rangle=|u_j\\rangle|\\frac{N\\lambda_jt}{2\\pi}|0\\rangle_a\n\\]\nSo far, we have assumed that \\(|b\\rangle\\) is an eigenvector of \\(U\\),\\(|u_j\\rangle\\). In general, \\(|b\\rangle\\) can be expressed as a superposition of \\(|u_j\\rangle\\). \\[\n|\\phi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}|b_j\\rangle|u_j\\rangle|\\frac{N\\lambda_jt}{2\\pi}|0\\rangle_a\n\\]\nchoose \\(t\\) so that \\(\\tilde{\\lambda_j}=\\frac{N\\lambda_jt}{2\\pi}\\) are integers, therefore, \\(\\tilde{\\lambda_j}\\) are usually scale of \\(\\lambda_j\\)\n\\(|\\psi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}|0\\rangle_a\\)\n\n\nCode\niqft = QFT(num_qubits=n_c, do_swaps=False).inverse()  # 创建 IQFT 门\npsi_4 = psi_3.copy()\npsi_4.append(iqft, qr_c)  # 作用在 c-register 上\n\npsi_4.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef phase_estimation(qc, qr_b, qr_c, mat_A, t):\n    n_c = len(qr_c)\n    \n    # 1. Hadamard on c-register\n    qc.h(qr_c)\n    \n    # 2. Apply controlled-U^(2^j) operations\n    U = expm(1j * t * mat_A)  # 计算 e^(iAt)\n    U_gate = UnitaryGate(U, label=\"e^{iAt}\")  # 创建 U gate\n  \n    for j in range(n_c):\n        power = 2**j  # 计算 U^(2^j)\n        controlled_U_pow = U_gate.power(power).control(1)  # 控制操作\n        qc.append(controlled_U_pow, [qr_c[j], *qr_b]) \n    \n    # 3. Apply IQFT on c-register\n    iqft = QFT(num_qubits=n_c, do_swaps=False).inverse()\n    qc.append(iqft, qr_c)  # 作用于 c-register\n    \n    return qc\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\n\n\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\n\npsi_4.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev State Preparation\nnext step is Controlled Rotation"
  },
  {
    "objectID": "posts/machine_learning/08.hhl_imp2.html#introduction",
    "href": "posts/machine_learning/08.hhl_imp2.html#introduction",
    "title": "HHL Algorithm Implementation in Qiskit - Quantum Phase Estimation (QPE)",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\n*Quantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\nUncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, choose \\(t\\) such that \\(\\tilde{\\lambda_j}=\\frac{\\lambda_jt}{2\\pi}\\) is an integer\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8"
  },
  {
    "objectID": "posts/machine_learning/08.hhl_imp2.html#phase-2-quantum-phase-estimation",
    "href": "posts/machine_learning/08.hhl_imp2.html#phase-2-quantum-phase-estimation",
    "title": "HHL Algorithm Implementation in Qiskit - Quantum Phase Estimation (QPE)",
    "section": "",
    "text": "The Goal for this phase is to estimate the eigenvalues of given Matrix.\n\n\n\\[\n\\begin{align}\n|\\psi_2\\rangle &= I^{\\otimes n_b}\\otimes H^{\\otimes n}\\otimes I |\\psi_1\\rangle \\\\\n&= |b\\rangle\\frac{1}{2^\\frac{n}{2}}(|0\\rangle+|1\\rangle)^{\\otimes n}|0\\rangle \\\\\n&= |b\\rangle\\frac{1}{\\sqrt2 ^n}(|0\\rangle+|1\\rangle)^{\\otimes n}|0\\rangle\n\\end{align}\n\\]\n其实就是每个state in c-register 都apply Hadamard gate (变成\\(\\frac{1}{\\sqrt2}(|0\\rangle+|1\\rangle)\\)) \\(\\frac{1}{\\sqrt2 ^ n}\\) 是因为\\(H^{\\otimes n_c}|0\\dots0\\rangle_c\\)\n\n\nCode\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_2 = psi_1.copy()\npsi_2.h(qr_c)\npsi_2.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nApply the control-\\(U\\) operation such that the eigenvalues of A would be stored in register-C. \\[\nU = e^{iAt}\n\\] Where \\(t\\) is the time. E.g. a state \\(|\\psi\\rangle\\) would be \\(e^{iAt}|\\psi\\rangle\\) after time \\(t\\).\nWe want to apply the control-\\(U\\) operation such that \\(U|b\\rangle = e^{2\\pi i \\phi}|b\\rangle\\), where \\(e^{2\\pi i \\phi}\\) is the eigenvalue of A (\\(A|\\phi\\rangle=e^{2\\pi i \\phi}|\\phi\\rangle\\)), esitmated from \\(U^{2r}, U=e^{iAt}\\). Where \\(r\\) is the index of the clock qubit (c-register). \nWhen the control clock qubit is \\(|0\\rangle\\), \\(|b\\rangle\\) will not be affected. If the clock bit is \\(|1\\rangle\\), \\(U\\) will be applied to \\(|b\\rangle\\). This is equivalent to multiplying \\(e^{2\\pi i \\phi 2^j}\\) in front of the \\(|1\\rangle\\) of the j-th clock qubit \\(|c_j\\rangle\\). (notice the \\(U^{2^r}\\) and \\(U^k\\) ahead, here \\(2j=2r\\) or \\(2j=k\\))\n\n\n\n受控 \\(U^{2^j}\\) 操作的目的是把 \\(e^{i\\lambda_i \\phi}\\) 编码到控制寄存器，通过 QFT 解析出 \\(\\lambda_i\\) 的相位信息。\n\\(e^{iAt}\\) 是时间演化矩阵，而我们希望将其转换成 \\(e^{2\\pi i \\phi}\\)， 使得 QFT 可以处理相位信息并测量出 \\(\\phi\\)。\n指数幂次 \\(U^{2^j}\\) 的目的是让相位信息能以足够高的分辨率存入控制寄存器，从而精确估计 \\(\\lambda_i\\)。\n最终，\\(\\lambda_i=\\frac{2\\pi\\phi}{t}\\)，通过控制寄存器的测量结果 \\(\\phi\\) 来反推出 \\(\\lambda_i\\)。\n\nafter controlled-\\(U\\) operation, we have \\[\n|\\psi_3\\rangle=|b\\rangle\\otimes\\frac{1}{\\sqrt2 ^n}~~~(|0\\rangle+e^{2\\pi i \\phi 2^{n-1}}|1\\rangle)\\otimes(|0\\rangle+e^{2\\pi i \\phi 2^{n-2}}|1\\rangle)\\otimes\\dots~~~\\otimes(|0\\rangle+e^{2\\pi i \\phi 2^{0}}|1\\rangle)\\otimes|0\\rangle_a\n\\] \\[\n|\\psi_3\\rangle=|b\\rangle \\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^{n}-1}_{k=0}e^{2\\pi i \\phi k}|k\\rangle |0\\rangle_a\n\\]\n\n\nCode\nU = expm(1j * t * mat_A)\nU_gate = UnitaryGate(U, label=\"e^\\{iAt\\}\")\ncontrolled_U = U_gate.control(1)  # controled gate by |1⟩\npsi_3 = psi_2.copy()\nfor j in range(n_c):\n    power = 2**j  # U^{2^j}\n    controlled_U_pow = U_gate.power(power).control(1)  # 计算 U^{2^j} 并加控制\n    psi_3.append(controlled_U_pow, [qr_c[j], *qr_b])\n\n\npsi_3.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\nApply IQFT, only clock qubits (c-register) are affected.\n\\[\n\\begin{align}\n|\\psi_4\\rangle &= |b\\rangle\\text{IQFT}(\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^{n}-1}_{k=0})|0\\rangle_a\\\\\n&=|b\\rangle\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i \\phi k}(\\text{IQFT}|k\\rangle)|0\\rangle_a\\\\\n&=|b\\rangle\\frac{1}{\\sqrt2 ^n}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i \\phi k}(\\sum\\limits^{2^n-1}_{y=0}e^{-2\\pi iyk/N}|y\\rangle)|0\\rangle_a\\\\\n&=\\frac{1}{\\sqrt2 ^n}|b\\rangle\\sum\\limits^{2^n-1}_{y=0}\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi i k (\\phi-y/N)}|y\\rangle|0\\rangle_a\n\\end{align}\n\\]\nonly \\(|y\\rangle\\) satisfying the condition \\(\\phi-y/N=0\\) will have a finite amplitude of \\(\\sum\\limits^{2^n-1}_{k=0}e^0=2^n\\) otherwise the amplitude is \\(\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi ik(\\phi-y/N)}=0\\). After ignoring the states of zero amplitude\n\\[\\begin{align}\n|\\psi_4\\rangle&=\\frac{1}{\\sqrt2 ^n}|b\\rangle\\sum\\limits^{2^n-1}_{k=0}e^{2\\pi ik.0}|N\\phi\\rangle|0\\rangle_a\\\\\n&=|b\\rangle|N\\phi\\rangle|0\\rangle_a\n\\end{align}\n\\]\nTherefore, in QPE, the clock qubits are used to represent the phase information of \\(U\\), which is \\(\\phi\\), and the accuracy depends on the number of qubits, \\(n\\).\nTo understand why the c-register is called the clock qubits and the meaning of t better, it is worth noting that the Hamiltonian of a system in quantum mechanics determines how a system evolves through the following equation,\\(U=e^{iAt}\\), and \\(t\\) can be treated as the evolution time for that Hamiltonian.\n\\(U\\) is also diagonal in \\(A\\)′s eigenvector, \\(|u_i\\rangle\\), basis. If \\(|b\\rangle=|u_j\\rangle\\).\\(U|b\\rangle=e^{i\\lambda_jt}|u_j\\rangle\\).\nlet \\(i\\lambda_jt=2\\pi i \\phi\\), we get \\(\\phi=\\frac{\\lambda_j t}{2\\pi}\\), and \\[\n|\\psi_4\\rangle=|u_j\\rangle|\\frac{N\\lambda_jt}{2\\pi}|0\\rangle_a\n\\]\nSo far, we have assumed that \\(|b\\rangle\\) is an eigenvector of \\(U\\),\\(|u_j\\rangle\\). In general, \\(|b\\rangle\\) can be expressed as a superposition of \\(|u_j\\rangle\\). \\[\n|\\phi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}|b_j\\rangle|u_j\\rangle|\\frac{N\\lambda_jt}{2\\pi}|0\\rangle_a\n\\]\nchoose \\(t\\) so that \\(\\tilde{\\lambda_j}=\\frac{N\\lambda_jt}{2\\pi}\\) are integers, therefore, \\(\\tilde{\\lambda_j}\\) are usually scale of \\(\\lambda_j\\)\n\\(|\\psi_4\\rangle=\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}|0\\rangle_a\\)\n\n\nCode\niqft = QFT(num_qubits=n_c, do_swaps=False).inverse()  # 创建 IQFT 门\npsi_4 = psi_3.copy()\npsi_4.append(iqft, qr_c)  # 作用在 c-register 上\n\npsi_4.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\ndef phase_estimation(qc, qr_b, qr_c, mat_A, t):\n    n_c = len(qr_c)\n    \n    # 1. Hadamard on c-register\n    qc.h(qr_c)\n    \n    # 2. Apply controlled-U^(2^j) operations\n    U = expm(1j * t * mat_A)  # 计算 e^(iAt)\n    U_gate = UnitaryGate(U, label=\"e^{iAt}\")  # 创建 U gate\n  \n    for j in range(n_c):\n        power = 2**j  # 计算 U^(2^j)\n        controlled_U_pow = U_gate.power(power).control(1)  # 控制操作\n        qc.append(controlled_U_pow, [qr_c[j], *qr_b]) \n    \n    # 3. Apply IQFT on c-register\n    iqft = QFT(num_qubits=n_c, do_swaps=False).inverse()\n    qc.append(iqft, qr_c)  # 作用于 c-register\n    \n    return qc\n\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\n\n\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\n\npsi_4.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev State Preparation\nnext step is Controlled Rotation"
  },
  {
    "objectID": "posts/machine_learning/10.hhl_imp4.html",
    "href": "posts/machine_learning/10.hhl_imp4.html",
    "title": "HHL Algorithm Implementation in Qiskit - Uncomputation (Inverse QPE)",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\n*Uncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\\(C=0.01\\): a constant to pick, try to make \\(C\\) as large as possible while \\(-1\\leq\\frac{C}{\\tilde{\\lambda_j}} \\leq 1\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01\n\n\n\n\n\n\nThe goal for this phase is to remove unnecessary entanglements such that ensures correct final measurement. After uncomputing, the quantum state should ideally be close to \\(|x\\rangle\\), where \\(|x\\rangle = A^{-1}|b\\rangle\\).\nAfter Uncomputation, we will finally get \\(\\psi_{final}=|x\\rangle\\otimes|0\\rangle_c\\otimes|0\\rangle_a\\)\n\n\nCode\n# prepare the previous steps\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\n# psi_6.draw(output='mpl')\n\n\n\n\nApply QFT on c-register to move the phase-encoded eigenvalue information into a superposition of computational basis states.\nGiven \\(|\\psi_6\\rangle=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\) \\[\n\\begin{align}\n|\\psi_7\\rangle &= \\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}*{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle\\text{QFT}|\\tilde{\\lambda_j}\\rangle|1\\rangle_a\\\\&=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}*{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~(\\frac{1}{2^{\\frac{2}{n}}}\\sum\\limits^{2^n-1}_{y=0}e^{2\\pi i y\\tilde{\\lambda_j}/N}|y\\rangle)~~~|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_7 = psi_6.copy()\npsi_7.append(QFT(n_c, do_swaps=False), qr_c)\n\npsi_7.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nThen inverse controlled-rotations of the b-register by the clock qubits are applied with \\(U^{−1} = e^{−iAt}\\).\nSimilar to the forward process, when the controlling r-th clock qubit is \\(|0\\rangle\\), \\(|u_j\\rangle\\) will not be affected. If the r-th clock qubit is \\(|1\\rangle\\), \\((U^{−1})^{2r}\\) will be applied to \\(|u_j\\rangle\\). This is equivalent to multiplying \\(e^{−i\\lambda_jty}\\) if the c-register is \\(|y\\rangle\\) since \\(2\\pi i \\phi=i\\lambda_jt\\)\n\\[\n|\\psi_8\\rangle=\\frac{1}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~\\left(\\sum\\limits^{2^n-1}_{y=0}e^{-i\\lambda_jty}e^{2\\pi i y\\tilde{\\lambda_j}/N}|y\\rangle\\right)~~~|1\\rangle_a\n\\]\nSince we choose \\(\\tilde{\\lambda_j}=\\frac{N\\lambda_jt}{2\\pi}\\), the two exponential terms cancel each other \\[\n\\begin{align}\n|\\psi_8\\rangle &=\\frac{1}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~\\sum\\limits^{2^n-1}_{y=0}|y\\rangle)~~~|1\\rangle_a\\\\\n&=\\frac{C}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}|x\\rangle\\sum\\limits^{2^n-1}_{y=0}|y\\rangle|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_8=psi_7.copy()\nU_inv = expm(-1j * t * mat_A)\nU_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")  # Inverse U gate\n\n\n# Apply inverse controlled-U operations in reverse order\nfor j in reversed(range(n_c)):\n    power = 2**j\n    controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n    psi_8.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n\npsi_8.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nThe clock qubits and the b-register are now unentangled and the b-register stores \\(|x\\rangle\\). Next, we can apply the Hadamard Gate on the clock qubits such that we get:\n\\[\n\\begin{align}\n|\\psi_9\\rangle &= \\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}|x\\rangle\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\lambda_j}|u_j\\rangle^{\\otimes n}_c|1\\rangle_a\\\\\n&=|x\\rangle_b|0\\rangle_c^{\\otimes n}|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_9 = psi_8.copy()\npsi_9.h(qr_c)\npsi_9.draw(output='mpl')\n# Do the measurement\nc_b = ClassicalRegister(len(qr_b), name='cb')  # 存储 b-register 测量值\nc_a = ClassicalRegister(1, name='ca')  # 存储 a-register 测量值\npsi_9.add_register(c_b, c_a)  # 添加经典寄存器\n\npsi_9.measure(qr_b, c_b)  # 测量 b-register 并存入 cb\npsi_9.measure(qr_a, c_a)  # 测量 a-register 并存入 ca\n\npsi_9.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\nCode\n# 运行并查看结果\nsimulator = Aer.get_backend('statevector_simulator')\nt_psi_9 = transpile(psi_9, simulator)\nresult = simulator.run(t_psi_9, shots=2 ** 10).result()\ncounts = result.get_counts(t_psi_9)\nprint(counts)\n\n# 解析测量结果\nmeasured_a1 = sum(counts[key] for key in counts if key[-1] == '1')\nmeasured_a0 = sum(counts[key] for key in counts if key[-1] == '0')\n\n# 计算归一化比值\nif measured_a1 + measured_a0 &gt; 0:\n    print(\"P(a=1) =\", measured_a1 / (measured_a1 + measured_a0))\n    print(\"P(a=0) =\", measured_a0 / (measured_a1 + measured_a0))\n\nfiltered_counts = {key[:-1]: count for key, count in counts.items() if key[-1] == '1'}\ntotal = sum(filtered_counts.values())\nif total &gt; 0:\n    print(\"b-register state after post-select:\")\n    for state, count in filtered_counts.items():\n        print(f\"|{state}⟩: {count/total:.4f}\")\n\n\n{'0 1': 1024}\nP(a=1) = 1.0\nP(a=0) = 0.0\nb-register state after post-select:\n|0 ⟩: 1.0000\n\n\n\n\n\n\n\nCode\ndef uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c):\n    \"\"\"\n    Complete uncomputation phase (Phase 4) of HHL algorithm\n    \"\"\"\n    # Step 1: Apply QFT on c-register\n    qc.append(QFT(n_c, do_swaps=False), qr_c)\n    \n    # Step 2: Inverse controlled-U operations\n    U_inv = expm(-1j * t * mat_A)\n    U_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")\n    \n    for j in reversed(range(n_c)):\n        power = 2**j\n        controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n        qc.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n    \n    # Step 3: Apply Hadamard on c-register\n    qc.h(qr_c)\n    \n    return qc\n\n# Test the uncomputation function\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\nC = 0.01\n\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\npsi_9 = uncomputation(psi_6, qr_b, qr_c, qr_a, mat_A, t, n_c=1)\n\n# Add measurement registers\nc_b = ClassicalRegister(len(qr_b), name='cb')\nc_a = ClassicalRegister(1, name='ca')\npsi_9.add_register(c_b, c_a)\npsi_9.measure(qr_b, c_b)\npsi_9.measure(qr_a, c_a)\n\npsi_9.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev Controlled Rotation\nnext is HHL Complete Version"
  },
  {
    "objectID": "posts/machine_learning/10.hhl_imp4.html#introduction",
    "href": "posts/machine_learning/10.hhl_imp4.html#introduction",
    "title": "HHL Algorithm Implementation in Qiskit - Uncomputation (Inverse QPE)",
    "section": "",
    "text": "This document provides a step-by-step implementation of the HHL algorithm using Qiskit. The algorithm is broken into four key phases:\n\nState Preparation\nQuantum Phase Estimation (QPE)\nControlled Rotation & Measurement of the Ancilla Qubit\n*Uncomputation (Inverse QPE)\n\n\n\n\\(A=\\begin{bmatrix}1 & -\\frac{1}{3}\\\\-\\frac{1}{3} & 1\\end{bmatrix}\\)\n\\(\\vec{b}=\\begin{bmatrix}0\\\\1\\end{bmatrix}\\)\n\n\n\n\\(n_b\\): # of qubits in b-register\n\\(N_b=2^{n_b}\\): # of unknows (length of \\(\\vec{b}\\), \\(len(\\vec{b})=len(\\vec{x})\\))\n\\(n_c\\): # of qubits in c-register\na larger \\(n_c\\) results in higher accuracy when the encoding is not exact\n\\(N=2^n\\)\n\\(t=\\frac{\\pi}{8}\\): time variable, should be multiple of \\(2\\pi\\)\n\\(C=0.01\\): a constant to pick, try to make \\(C\\) as large as possible while \\(-1\\leq\\frac{C}{\\tilde{\\lambda_j}} \\leq 1\\)\n\n\nCode\nN_b = 2 # number of variables (b.shape[0])\nn_b = int(np.log2(N_b)) # number of qubits in b-register\n# n_b = 1 # N_b = 2^(n_b), n_b = np.log2(N_b)\nn_c = 1 # number of qubits in c-register\nN_c = 2 # N_c = 2^(n_c)\nt = np.pi/8\nC = 0.01"
  },
  {
    "objectID": "posts/machine_learning/10.hhl_imp4.html#phase-4-uncomputation-inverse-qpe",
    "href": "posts/machine_learning/10.hhl_imp4.html#phase-4-uncomputation-inverse-qpe",
    "title": "HHL Algorithm Implementation in Qiskit - Uncomputation (Inverse QPE)",
    "section": "",
    "text": "The goal for this phase is to remove unnecessary entanglements such that ensures correct final measurement. After uncomputing, the quantum state should ideally be close to \\(|x\\rangle\\), where \\(|x\\rangle = A^{-1}|b\\rangle\\).\nAfter Uncomputation, we will finally get \\(\\psi_{final}=|x\\rangle\\otimes|0\\rangle_c\\otimes|0\\rangle_a\\)\n\n\nCode\n# prepare the previous steps\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\n\n# psi_6.draw(output='mpl')\n\n\n\n\nApply QFT on c-register to move the phase-encoded eigenvalue information into a superposition of computational basis states.\nGiven \\(|\\psi_6\\rangle=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}b_j|u_j\\rangle|\\tilde{\\lambda_j}\\rangle\\frac{C}{\\tilde{\\lambda_j}}|1\\rangle_a\\) \\[\n\\begin{align}\n|\\psi_7\\rangle &= \\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}*{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle\\text{QFT}|\\tilde{\\lambda_j}\\rangle|1\\rangle_a\\\\&=\\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}*{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~(\\frac{1}{2^{\\frac{2}{n}}}\\sum\\limits^{2^n-1}_{y=0}e^{2\\pi i y\\tilde{\\lambda_j}/N}|y\\rangle)~~~|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_7 = psi_6.copy()\npsi_7.append(QFT(n_c, do_swaps=False), qr_c)\n\npsi_7.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nThen inverse controlled-rotations of the b-register by the clock qubits are applied with \\(U^{−1} = e^{−iAt}\\).\nSimilar to the forward process, when the controlling r-th clock qubit is \\(|0\\rangle\\), \\(|u_j\\rangle\\) will not be affected. If the r-th clock qubit is \\(|1\\rangle\\), \\((U^{−1})^{2r}\\) will be applied to \\(|u_j\\rangle\\). This is equivalent to multiplying \\(e^{−i\\lambda_jty}\\) if the c-register is \\(|y\\rangle\\) since \\(2\\pi i \\phi=i\\lambda_jt\\)\n\\[\n|\\psi_8\\rangle=\\frac{1}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~\\left(\\sum\\limits^{2^n-1}_{y=0}e^{-i\\lambda_jty}e^{2\\pi i y\\tilde{\\lambda_j}/N}|y\\rangle\\right)~~~|1\\rangle_a\n\\]\nSince we choose \\(\\tilde{\\lambda_j}=\\frac{N\\lambda_jt}{2\\pi}\\), the two exponential terms cancel each other \\[\n\\begin{align}\n|\\psi_8\\rangle &=\\frac{1}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\tilde{\\lambda_j}}|u_j\\rangle~~~\\sum\\limits^{2^n-1}_{y=0}|y\\rangle)~~~|1\\rangle_a\\\\\n&=\\frac{C}{2^{\\frac{n}{2}}\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}|x\\rangle\\sum\\limits^{2^n-1}_{y=0}|y\\rangle|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_8=psi_7.copy()\nU_inv = expm(-1j * t * mat_A)\nU_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")  # Inverse U gate\n\n\n# Apply inverse controlled-U operations in reverse order\nfor j in reversed(range(n_c)):\n    power = 2**j\n    controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n    psi_8.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n\npsi_8.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\n\nThe clock qubits and the b-register are now unentangled and the b-register stores \\(|x\\rangle\\). Next, we can apply the Hadamard Gate on the clock qubits such that we get:\n\\[\n\\begin{align}\n|\\psi_9\\rangle &= \\frac{1}{\\sqrt{\\sum\\limits^{2^{n_b}-1}_{j=0}|\\frac{b_jC}{\\tilde{\\lambda_j}}|^2}}|x\\rangle\\sum\\limits^{2^{n_b}-1}_{j=0}\\frac{b_jC}{\\lambda_j}|u_j\\rangle^{\\otimes n}_c|1\\rangle_a\\\\\n&=|x\\rangle_b|0\\rangle_c^{\\otimes n}|1\\rangle_a\n\\end{align}\n\\]\n\n\nCode\npsi_9 = psi_8.copy()\npsi_9.h(qr_c)\npsi_9.draw(output='mpl')\n# Do the measurement\nc_b = ClassicalRegister(len(qr_b), name='cb')  # 存储 b-register 测量值\nc_a = ClassicalRegister(1, name='ca')  # 存储 a-register 测量值\npsi_9.add_register(c_b, c_a)  # 添加经典寄存器\n\npsi_9.measure(qr_b, c_b)  # 测量 b-register 并存入 cb\npsi_9.measure(qr_a, c_a)  # 测量 a-register 并存入 ca\n\npsi_9.draw(output='mpl')\n\n\n\n\n\n\n\n\n\n\n\nCode\n# 运行并查看结果\nsimulator = Aer.get_backend('statevector_simulator')\nt_psi_9 = transpile(psi_9, simulator)\nresult = simulator.run(t_psi_9, shots=2 ** 10).result()\ncounts = result.get_counts(t_psi_9)\nprint(counts)\n\n# 解析测量结果\nmeasured_a1 = sum(counts[key] for key in counts if key[-1] == '1')\nmeasured_a0 = sum(counts[key] for key in counts if key[-1] == '0')\n\n# 计算归一化比值\nif measured_a1 + measured_a0 &gt; 0:\n    print(\"P(a=1) =\", measured_a1 / (measured_a1 + measured_a0))\n    print(\"P(a=0) =\", measured_a0 / (measured_a1 + measured_a0))\n\nfiltered_counts = {key[:-1]: count for key, count in counts.items() if key[-1] == '1'}\ntotal = sum(filtered_counts.values())\nif total &gt; 0:\n    print(\"b-register state after post-select:\")\n    for state, count in filtered_counts.items():\n        print(f\"|{state}⟩: {count/total:.4f}\")\n\n\n{'0 1': 1024}\nP(a=1) = 1.0\nP(a=0) = 0.0\nb-register state after post-select:\n|0 ⟩: 1.0000\n\n\n\n\n\n\n\nCode\ndef uncomputation(qc, qr_b, qr_c, qr_a, mat_A, t, n_c):\n    \"\"\"\n    Complete uncomputation phase (Phase 4) of HHL algorithm\n    \"\"\"\n    # Step 1: Apply QFT on c-register\n    qc.append(QFT(n_c, do_swaps=False), qr_c)\n    \n    # Step 2: Inverse controlled-U operations\n    U_inv = expm(-1j * t * mat_A)\n    U_gate_inv = UnitaryGate(U_inv, label=\"e^{-iAt}\")\n    \n    for j in reversed(range(n_c)):\n        power = 2**j\n        controlled_U_pow_inv = U_gate_inv.power(power).control(1)\n        qc.append(controlled_U_pow_inv, [qr_c[j], *qr_b])\n    \n    # Step 3: Apply Hadamard on c-register\n    qc.h(qr_c)\n    \n    return qc\n\n# Test the uncomputation function\nmat_A = np.array([[1, -1/3], [-1/3, 1]])\nvec_b = np.array([0,1])\nt = np.pi/8\nC = 0.01\n\npsi_1, qr_b, qr_c, qr_a = state_prep(mat_A, vec_b, n_c=1)\npsi_4 = phase_estimation(psi_1, qr_b, qr_c, mat_A, t)\npsi_6 = controlled_rotation(psi_4, qr_c, qr_a, C=C, t=t, n_c=n_c)\npsi_9 = uncomputation(psi_6, qr_b, qr_c, qr_a, mat_A, t, n_c=1)\n\n# Add measurement registers\nc_b = ClassicalRegister(len(qr_b), name='cb')\nc_a = ClassicalRegister(1, name='ca')\npsi_9.add_register(c_b, c_a)\npsi_9.measure(qr_b, c_b)\npsi_9.measure(qr_a, c_a)\n\npsi_9.draw(output='mpl')\n\n\n\n\n\n\n\n\n\nprev Controlled Rotation\nnext is HHL Complete Version"
  },
  {
    "objectID": "posts/machine_learning/machine_learning.html",
    "href": "posts/machine_learning/machine_learning.html",
    "title": "Blogs in Machine Learning",
    "section": "",
    "text": "About this series\nBlogs in Machine learning\n\n\n\n\n\n\n   \n    \n    \n      Order By\n      Default\n      \n        Title\n      \n      \n        Date - Oldest\n      \n      \n        Date - Newest\n      \n    \n  \n    \n      \n      \n    \n\n\n\n\n\nHHL Algorithm Implementation in Qiskit - Quantum Phase Estimation (QPE)\n\n\n\nPython\n\nQuantum Computing\n\n\n\nImplement my verison of HHL step by step with a numerical example\n\n\n\n\n\nJan 20, 2025\n\n5 min\n\n\n\n\n\n\nHHL Algorithm Implementation in Qiskit - Controlled Rotation & Measurement of the Ancilla Qubit\n\n\n\nPython\n\nQuantum Computing\n\n\n\nImplement my verison of HHL step by step with a numerical example\n\n\n\n\n\nJan 20, 2025\n\n11 min\n\n\n\n\n\n\nHHL Algorithm Implementation in Qiskit - Uncomputation (Inverse QPE)\n\n\n\nPython\n\nQuantum Computing\n\n\n\nImplement my verison of HHL step by step with a numerical example\n\n\n\n\n\nJan 20, 2025\n\n8 min\n\n\n\n\n\n\nHHL Algorithm Implementation in Qiskit - Complete Version\n\n\n\nPython\n\nQuantum Computing\n\n\n\nImplement my verison of HHL step by step with a numerical example\n\n\n\n\n\nJan 20, 2025\n\n7 min\n\n\n\n\n\n\nHHL Algorithm Implementation in Qiskit - State Preparation\n\n\n\nPython\n\nQuantum Computing\n\n\n\nImplement my verison of HHL step by step with a numerical example\n\n\n\n\n\nJan 15, 2025\n\n3 min\n\n\n\n\n\n\nPredicting Diamond Prices: A Naive Bayes Approach\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nProbability\n\nNaive Bayes\n\n\n\nThis project applies Probability and the Naive Bayes algorithm to predict diamond prices using the categorical features of the Seaborn’s diamonds dataset, demonstrating the algorithm’s efficiency in handling such data.\n\n\n\n\n\nNov 16, 2023\n\n5 min\n\n\n\n\n\n\nClustering on Brain Networks Observations\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nClustering\n\nDBSCAN\n\nScikit-Learn\n\n\n\nThis project applies clustering algorithms on seaborn’s brain_networks dataset, notably implementing DBSCAN from scratch and comparing results from various scikit-learn models.\n\n\n\n\n\nNov 16, 2023\n\n6 min\n\n\n\n\n\n\nHarnessing Momentum: Predictive Analysis of Stock Prices Using Linear and Nonlinear Regression I\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nLinear Regression\n\nNonlinear Regression\n\nMomentum Strategy\n\nStock Prediction\n\n\n\nImplement my own version of linear regression and logistic regression and construct a momentum strategy based on my models in stock market. Phrase I, model implementation\n\n\n\n\n\nNov 16, 2023\n\n9 min\n\n\n\n\n\n\nHarnessing Momentum: Predictive Analysis of Stock Prices Using Linear and Nonlinear Regression II\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nLinear Regression\n\nNonlinear Regression\n\nMomentum Strategy\n\nStock Prediction\n\n\n\nImplement my own version of linear regression and logistic regression and construct a time series momentum strategy based on my models in stock market. Phrase II, momentum strategy\n\n\n\n\n\nNov 16, 2023\n\n7 min\n\n\n\n\n\n\nMnist dataset classification\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nClassification\n\nPerceptron\n\nNerual Network\n\n\n\nThis project applies a one-layer perceptron, a simple form of a neural network, to classify handwritten digits from the MNIST dataset, providing insights into image recognition and machine learning model development.\n\n\n\n\n\nNov 16, 2023\n\n4 min\n\n\n\n\n\n\nOutlier Detection in Dow Jones using Support Vector Machines\n\n\n\nPython\n\nCS5805 23Fall\n\nMachine Learning\n\nAnomaly/outlier detection\n\nSupport Vector Machine (SVM)\n\n\n\nExplore the application of SVM for anomaly detection in the Dow Jones data.\n\n\n\n\n\nNov 16, 2023\n\n6 min\n\n\n\n\n\n\n01 week01\n\n\n\nPython\n\nlang:Chinese\n\n\n\nweek01 class materials, simple jupyter notebook tips\n\n\n\n\n\nOct 6, 2023\n\n1 min\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cover page",
    "section": "",
    "text": "About this blog\ntry to do some interaction here later\n\n3 - Code\nThis is inline code plus a small code chunk.\n\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline\ndf = pd.DataFrame(data=[[1,2,3,4],\n[4,3,2,1]], columns=[\"A\",\"B\",\"C\",\"D\"],index=[\"E\", \"F\"])\n# print(df)\nplt.plot(df)\n\n\n\n\n\n\n\n\n11111\n\ndf\n\n\n\n\n\n\n\nA\nB\nC\nD\n\n\n\n\nE\n1\n2\n3\n4\n\n\nF\n4\n3\n2\n1\n\n\n\n\n\n\n\n4 - Some math stuff\n\\[\n\\int_0^1 f(x) \\ dx\n\\]"
  },
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "Blogs",
    "section": "",
    "text": "Series\n\nIntro to Python\n\n\nMachine Learning\n\n\nMisc\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWelcome To My Blog\n\n\n\nnews\n\n\n\n\n\n\n\n\n\nSep 9, 2023\n\n\nTristan O’Malley\n\n\n\n\n\nNo matching items"
  }
]